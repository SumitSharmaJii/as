<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catch the Hearts</title>
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    canvas {
      background-color: var(--light-pink);
      border-radius: var(--border-radius);
      touch-action: none; /* Prevent default touch scrolling on canvas */
      max-width: 100%;
      height: auto;
    }
    
    /* Responsive canvas sizing */
    @media (max-width: 640px) {
      canvas {
        width: 100%;
        max-width: 350px;
        height: 525px; /* Maintain 3:2 aspect ratio */
      }
    }
    
    @media (min-width: 641px) and (max-width: 1024px) {
      canvas {
        width: 100%;
        max-width: 450px;
        height: 675px;
      }
    }
    
    @media (min-width: 1025px) {
      canvas {
        width: 400px;
        height: 600px;
      }
    }
  </style>
</head>
<body>
  <!-- Floating Hearts Background -->
  <div class="floating-hearts">
    <div class="heart">ğŸ’–</div>
    <div class="heart">ğŸ’•</div>
    <div class="heart">ğŸ’“</div>
    <div class="heart">ğŸ’—</div>
    <div class="heart">ğŸ’˜</div>
    <div class="heart">ğŸ’–</div>
    <div class="heart">ğŸ’•</div>
    <div class="heart">ğŸ’“</div>
    <div class="heart">ğŸ’—</div>
  </div>

  <div class="main-layout">
    <div class="game-container">
      <h1 class="text-3xl font-bold text-pink-700 mb-4 text-center">Catch the Hearts, <%= girlName %> ğŸ’–</h1>
      
      <canvas id="gameCanvas" width="400" height="600"></canvas>
      
      <div class="card text-center">
        <div class="mb-4">
          <h2 class="text-2xl font-bold text-pink-700 mb-2">Score</h2>
          <p class="text-3xl font-bold text-pink-600">
            <span id="score">0</span>
          </p>
        </div>
        
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm text-gray-800">
          <div>
            <h3 class="font-semibold mb-2">ğŸ® Controls</h3>
            <p>â€¢ Arrow keys to move</p>
            <p>â€¢ Click & drag on mobile</p>
            <p>â€¢ Mouse drag on desktop</p>
          </div>
          <div>
            <h3 class="font-semibold mb-2">ğŸ¯ Objective</h3>
            <p>â€¢ Catch falling hearts</p>
            <p>â€¢ Don't let them fall!</p>
            <p>â€¢ Score as high as you can</p>
          </div>
        </div>
      </div>
      
      <a href="/" class="back-btn">
        â† Back Home
      </a>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let basket;
    let score = 0;
    let hearts = [];
    let gameRunning = true;

    // Responsive canvas sizing
    function resizeCanvas() {
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      
      if (containerWidth <= 640) {
        canvas.width = 350;
        canvas.height = 525;
      } else if (containerWidth <= 1024) {
        canvas.width = 450;
        canvas.height = 675;
      } else {
        canvas.width = 400;
        canvas.height = 600;
      }
      
      // Initialize or reset basket position after resize
      if (!basket) {
        basket = {
          x: (canvas.width - 80) / 2,
          y: canvas.height - 50,
          width: 80,
          height: 20,
          speed: 6
        };
      } else {
        basket.x = (canvas.width - basket.width) / 2;
        basket.y = canvas.height - 50;
      }
    }

    // Initial resize
    resizeCanvas();
    
    // Resize on window resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      hearts = []; // Clear hearts on resize
    });

    function drawBasket() {
      const primaryPink = getComputedStyle(document.documentElement).getPropertyValue('--primary-pink').trim();
      
      // Draw basket with gradient effect
      const gradient = ctx.createLinearGradient(basket.x, basket.y, basket.x, basket.y + basket.height);
      gradient.addColorStop(0, primaryPink);
      gradient.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--dark-pink').trim());
      
      ctx.fillStyle = gradient;
      ctx.fillRect(basket.x, basket.y, basket.width, basket.height);
      
      // Add basket border
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--dark-pink').trim();
      ctx.lineWidth = 2;
      ctx.strokeRect(basket.x, basket.y, basket.width, basket.height);
    }

    function drawHeart(x, y) {
      ctx.beginPath();
      ctx.fillStyle = "#e11d48"; // Better red color
      ctx.strokeStyle = "#be123c";
      ctx.lineWidth = 2;
      
      // Draw a more detailed heart
      const size = 15;
      ctx.moveTo(x, y + size);
      ctx.bezierCurveTo(x, y, x - size, y, x - size, y + size);
      ctx.bezierCurveTo(x - size, y + size * 2, x, y + size * 3, x, y + size * 3);
      ctx.bezierCurveTo(x, y + size * 3, x + size, y + size * 2, x + size, y + size);
      ctx.bezierCurveTo(x + size, y, x, y, x, y + size);
      
      ctx.fill();
      ctx.stroke();
    }

    function drawHearts() {
      hearts.forEach(h => {
        drawHeart(h.x, h.y);
      });
    }

    function updateHearts() {
      hearts.forEach(h => h.y += h.speed);

      // collision detection
      hearts = hearts.filter(h => {
        if (
          h.y + 20 >= basket.y &&
          h.x >= basket.x &&
          h.x <= basket.x + basket.width
        ) {
          score++;
          document.getElementById("score").innerText = score;
          return false;
        }
        return h.y < canvas.height;
      });
    }

    function spawnHeart() {
      if (!gameRunning) return;
      const x = Math.random() * (canvas.width - 50) + 25;
      hearts.push({ x, y: -50, speed: 2 + Math.random() * 3 });
    }

    function draw() {
      if (!gameRunning) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBasket();
      drawHearts();
      updateHearts();
      requestAnimationFrame(draw);
    }

    // Keyboard controls
    document.addEventListener("keydown", e => {
      if (!basket) return;
      
      if (e.key === "ArrowLeft" && basket.x > 0) {
        basket.x -= basket.speed;
      }
      if (e.key === "ArrowRight" && basket.x < canvas.width - basket.width) {
        basket.x += basket.speed;
      }
    });

    // Touch and mouse drag controls
    let dragging = false;

    function clampBasketX(x) {
      if (!basket) return 0;
      return Math.min(Math.max(0, x - basket.width / 2), canvas.width - basket.width);
    }

    // For touch devices
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      if (!basket) return;
      
      dragging = true;
      const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
      basket.x = clampBasketX(touchX);
    });

    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      if (!dragging || !basket) return;
      
      const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
      basket.x = clampBasketX(touchX);
    });

    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      dragging = false;
    });

    // For mouse drag
    canvas.addEventListener("mousedown", e => {
      e.preventDefault();
      if (!basket) return;
      
      dragging = true;
      const mouseX = e.clientX - canvas.getBoundingClientRect().left;
      basket.x = clampBasketX(mouseX);
    });

    canvas.addEventListener("mousemove", e => {
      if (!dragging || !basket) return;
      
      const mouseX = e.clientX - canvas.getBoundingClientRect().left;
      basket.x = clampBasketX(mouseX);
    });

    canvas.addEventListener("mouseup", e => {
      dragging = false;
    });

    canvas.addEventListener("mouseleave", e => {
      dragging = false;
    });

    // Start the game
    setInterval(spawnHeart, 800);
    draw();
  </script>
</body>
</html>
